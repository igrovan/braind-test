<?php

// задаём минимальное значение 1, на основе приведённого примера
define('MIN_VALUE', 1);

// задаём отрезок рассматриваемых чисел
$numbersLen = $_POST['numbersLen'];

// задаём интересующее число
$number = $_POST['number'];

// проверим полученные значения на существование и соответствие условию

$error_message = '';

switch (true) {
    case (!is_numeric($numbersLen)):
        $error_message = 'Отрезок рассматриваемых чисел не задан!';
        break;
    case ($numbersLen < MIN_VALUE):
        $error_message = sprintf('Отрезок рассматриваемых чисел меньше %d!', MIN_VALUE);
        break;
    case (!is_numeric($number)):
        $error_message = 'Интересующее число не задано!';
        break;
    case ($number < MIN_VALUE):
        $error_message = sprintf('Интересующее число меньше %d!', MIN_VALUE);
        break;
    case ($number > $numbersLen):
        $error_message = 'Интересующее число больше рассматриваемого отрезка!';
        break;
}

// вернём ошибку при наличии
if ($error_message) {
    echo '<p class="error">' . $error_message . '</p>';
    return;
}

// выведем позицию интересующего числа
echo '<p> позиция числа - ' . strangeMathSearch($numbersLen, $number) . '</p>';

// для проверки полученного результата имеется возможность вывести результат с использованием функции sort
// echo '<p> позиция числа (c использованием Sort) - ' . standartSortSearch($numbersLen, $number) . '</p>';

// функция поиска позиции числа в заданном отрезке чисел
function strangeMathSearch($numbersLen, $number) {

    // инициализируем переменную
    $numberPos = 0;

    // зададим переменную массива
    $array = array();

    // добавим числа в массив согласно заданной длины рассматриваемого отрезка
    for ($i = MIN_VALUE; $i <= $numbersLen; $i++) {
        $array[] = $i;
    }

    // зададим внешний цикл по количеству рассматриваемых элементов
    for ($j = 0; $j < $numbersLen; $j++) {
        /* зададим внутренний цикл. Поскольку после выполнения каждого внешнего цикла j-тое число с конца 
        будет отсортировано корректно - необходимости повторной проверке этого и последующих чисел нет.
        Поскольку внутри цикла будут сравниваться два числа - добавляем в условие "-1", чтобы не выйти за пределы массива. */
        for ($i = 0; $i < $numbersLen - $j - 1; $i++) {
            // проверим больше ли текущий элемент по сравнению со следующим с лексикографической точки зрения
            if (strcmp($array[$i], $array[$i + 1]) > 0) {
                // запишем следующий элемент во временную переменную
                $tmp_var = $array[$i + 1];
                //поменяем элементы местами
                $array[$i + 1] = $array[$i];
                $array[$i] = $tmp_var;
            };
        };
    };

    // найдем позицию числа в массиве и прибавим единицу, поскольку нумерация ключей идёт с 0
    $numberPos = array_search($number, $array) + 1;

    // возвращаем позицию числа
    return $numberPos;
}

// функция поиска позиции числа в заданном отрезке чисел c применением стандартной сортировки
function standartSortSearch($numbersLen, $number) {

    // зададим переменную массива
    $array = array();

    // добавим числа в массив согласно заданной длины рассматриваемого отрезка
    for ($i = MIN_VALUE; $i <= $numbersLen; $i++) {
        $array[] = $i;
    }

    // отсортируем элементы массива лексикографически
    sort($array, SORT_STRING);

    // найдем позицию числа в массиве и прибавим единицу, поскольку нумерация ключей идёт с 0
    $numberPos = array_search($number, $array) + 1;

    // возвращаем позицию числа
    return $numberPos;
}
